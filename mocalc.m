% Contains the SCF algorithm.
% 
% Input:
%     atoms               list of element numbers (array with K elements); 
%                             e.g. [6 8] for CO
%     xyz_a0              K×3 array of Cartesian coordinates of nuclei, in bohr
%     totalcharge         total charge of the molecule, in units of elementary charge
%     settings            a structure that contains several fields:
%         .basisset           string specifying the basis set, e.g. '6-31G', 'cc-pVDZ', 'STO-3G'    
%         .tolEnergy          SCF convergence tolerance for the energy (hartrees)
%         .tolDensity         SCF convergence tolerance for the density ((a0)^?3)
%         
% Output:
%     out                 a structure that contains several fields:
%         .basis          list of basis functions, as generated by buildbasis
%         .S              overlap matrix (M×M)
%         .T              kinetic energy matrix (M×M)
%         .Vne            electron-nuclear attraction matrix (M×M)
%         .J              matrix of Coulomb integrals (M×M)
%         .K              matrix of exchange integrals (M×M)
%         .ERI            4D array of electron-electron repulsion integrals (M×M×M×M)  
%         .epsilon        MO energies (1×M), in hartrees, in ascending order,
%                         consisting of both occupied and virtual orbitals
%         .C              MO coefficient matrix (M×M), of occupied and virtual 
%                         orbitals, sorted in ascending order of orbital energy
%         .P              density matrix (M×M)
%         .E0             electronic ground-state energy of the molecule, in hartrees
%         .Etot           total ground-state energy (including nuclear-nuclear repulsion; 
%                         but without the vibrational zero-point energy), in hartrees
                        
function out = mocalc(atoms,xyz_a0,totalcharge,settings)

% Cleaning the inputs.
BasisSetName    = settings.basisset;       
E_tol           = settings.tolEnergy;   % tolerance energy change (hartrees)
P_tol           = settings.tolDensity;  % tolerance density element change ((a0)^-3)

% Defining some variables that will be used throughout.
out = {};                           % initializing the return structure.
N = sum(atoms) - totalcharge;       % total # of e in molecule.

% Building the outputs.
bdef      = basisread(BasisSetName);
basis     = buildbasis(atoms,xyz_a0,bdef);
S         = int_overlap(basis);                 % symmetrized, diagonals = 1
T         = int_kinenergy(basis);
Vne       = int_attraction(atoms,xyz_a0,basis);
ERI       = int_repulsion(basis);
M         = numel(basis);                       % number of basis functions.
J         = zeros(M);                           % initializing Coulomb matrix
for mu = 1:M
    for nu = 1:M
        for kap = 1:M
            for lam = 1:M
                J(mu,nu) = J(mu,nu) + ERI(mu,kap,nu,lam); % calc J elements
            end
        end
    end
end
K = -0.5 * J;   % due to symmetry of 2e integrals.

% SCF Loop.
counter = 0;
while true      % mimicking a C++ do-while loop.
    counter = counter + 1;
    if counter == 1
        F = T + Vne;                % initial approx F matrix (ignore e-e rep).
    else
        F = T + Vne + (J - K)*P;    % MxM F matrix for SCF iterations after
                                    % starting density matrix has been
                                    % estimated.
    end
    F            = (F*F.')/10;      % symmetrization & downscaling.
    [C,epsi]     = eig(F,S);        % Matlab's general eigenproblem solver to
                                    % approx MO coeff and energy matrices.
    diagonals    = diag(epsi);      % diagonal energy matrix -> column vect.             
    [sorted,idx] = sort(diagonals);
    epsi         = sorted;         % 1xM row vector, vals in ascending order. 
    C            = C(:,idx);        % C sorted based on sorted e values.
    for k = 1:M
      norms(k) = sqrt(C(:,k).'*S*C(:,k));
    end
    C_norm = C./norms;              % normalizing C.
    P = 2*(C*C.');                  % estimation of starting density matrix.
    E = sum(epsi);

    if counter > 1
        E_change = E - E_prev;
        P_change = max(abs((P(:) - P_prev(:))));

        if E_change < E_tol && P_change < P_tol
            break;
        end
    end
    
    E_prev = E;
    P_prev = P;
end

% assert(trace(P) == N);

out.basis   = basis;
out.S       = S;
out.T       = T;
out.Vne     = Vne;
out.ERI     = ERI;
out.J       = J;
out.K       = K;
out.epsilon = epsi;
out.C       = C;
out.P       = P;
out.E0      = epsi(1);
out.Etot    = E;
end
 
 


% Contains the SCF algorithm.
% 
% Input:
%     atoms               list of element numbers (array with K elements); 
%                             e.g. [6 8] for CO
%     xyz_a0              K×3 array of Cartesian coordinates of nuclei, in bohr
%     totalcharge         total charge of the molecule, in units of elementary charge
%     settings            a structure that contains several fields:
%         .basisset           string specifying the basis set, e.g. '6-31G', 'cc-pVDZ', 'STO-3G'    
%         .tolEnergy          SCF convergence tolerance for the energy (hartrees)
%         .tolDensity         SCF convergence tolerance for the density ((a0)^?3)
%         
% Output:
%     out                 a structure that contains several fields:
%         .basis          list of basis functions, as generated by buildbasis
%         .S              overlap matrix (M×M)
%         .T              kinetic energy matrix (M×M)
%         .Vne            electron-nuclear attraction matrix (M×M)
%         .J              matrix of Coulomb integrals (M×M)
%         .K              matrix of exchange integrals (M×M)
%         .ERI            4D array of electron-electron repulsion integrals (M×M×M×M)  
%         .epsilon        MO energies (1×M), in hartrees, in ascending order,
%                         consisting of both occupied and virtual orbitals
%         .C              MO coefficient matrix (M×M), of occupied and virtual 
%                         orbitals, sorted in ascending order of orbital energy
%         .P              density matrix (M×M)
%         .E0             electronic ground-state energy of the molecule, in hartrees
%         .Etot           total ground-state energy (including nuclear-nuclear repulsion; 
%                         but without the vibrational zero-point energy), in hartrees
                        
function out = mocalc(atoms,xyz_a0,totalcharge,settings)

% Cleaning the inputs.
BasisSetName    = settings.basisset;       
E_tol           = settings.tolEnergy;   % tolerance energy change (hartrees)
P_tol           = settings.tolDensity;  % tolerance density element change ((a0)^-3)

% Defining some variables that will be used throughout.
out = {};                           % initializing the return structure.
N = sum(atoms) - totalcharge;       % total # of e in molecule.

% Building the outputs.
bdef      = basisread(BasisSetName);
basis     = buildbasis(atoms,xyz_a0,bdef);
S         = int_overlap(basis);                 % symmetrized, diagonals = 1
T         = int_kinenergy(basis);
Vne       = int_attraction(atoms,xyz_a0,basis);
Vnn       = nucnucrepulsion(atoms,xyz_a0);
ERI       = int_repulsion(basis);
M         = numel(basis);                       % number of basis functions.

out.ERI     = ERI;
out.S       = S;
out.Vne     = Vne;
out.T       = T;

% SCF Loop.
counter = 0;
converged = false;
while ~converged    
    counter = counter + 1;
    if counter == 1
        F = T + Vne;        % initial approx F matrix (ignore e-e rep).
    else
        F = T + Vne + P;    % MxM F matrix for SCF iterations after
                            % starting density matrix has been estimated.
    end
    [C,epsi]  = eig(F,S);        % Matlab's general eigenproblem solver to
                                    % approx MO coeff and energy matrices.
                                    

    diagonals = diag(epsi);      % diagonal energy matrix -> column vect. 
    [sorted,idx] = sort(diagonals);
    epsi         = sorted;          % Mx1 matrix of energy vals in ascending order.
    for k = 1:M
      norms(k) = sqrt(C(:,k).'*S*C(:,k));
      C(:,k) = C(:,k)./norms(k);    % normalizing C
    end
    C     = C(:,idx);           % C sorted based on sorted e values.
    C_occ = C(:,1:N/2);         % reducing C to occupied orbitals only
    P     = 2*(C_occ*C_occ.');  % estimation of starting density matrix.
    
    J         = zeros(M);                           % initializing Coulomb matrix.
    K         = zeros(M);                           % initializing Exchange matrix.
    for mu = 1:M
        for nu = 1:M
            for kap = 1:M
                for lam = 1:M
                    J(mu,nu) = J(mu,nu) + P(kap,lam)*ERI(mu,nu,lam,kap); % calc J elements
                    K(mu,nu) = K(mu,nu) + 0.5*P(kap,lam)*ERI(mu,kap,lam,nu); % calc K elements
                end
            end
        end
    end
    
    E0 = 0;
    for u = 1:M
        for v = 1:M
            E0 = E0 + P(u,v)*(T(u,v) + Vne(u,v) + 0.5*(J(u,v) - K(u,v)));
        end
    end
    
    if counter > 1
        E_change = E0 - E0_prev;
        P_change = max(abs((P(:) - P_prev(:))));
        if E_change < E_tol && P_change < P_tol
            converged = true;
        end
    end
    
    E0_prev = E0;
    P_prev = P;
    
out.basis   = basis;
out.J       = J;
out.K       = K;
out.epsilon = epsi;
out.C       = C;
out.P       = P;
out.E0      = E0;
out.Etot    = E0 + Vnn;

end

% assert(trace(P) == N);


end
 
 

